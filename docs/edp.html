<!DOCTYPE html>
<html>
<head>
  <title>Event-Driven Programming | Obj JS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='stylesheet' href='Kempo.css' />
  <script src='jquery-3.1.1.min.js'></script>
  <script src='Kempo.js'></script>
</head>
<body>
  <kempo-include src='nav.inc.html'></kempo-include>
  <kempo-wrapper>
    <h1 center>Event-Driven Programming</h1>
    <p>Event-Driven Programming (<b>EDP</b>) is an alternative way of handling callbacks. Traditionally if we had an object and we wanted to know when something happened within the object we would pass some callbacks into the constructor that would be used to notify an outside script that something happened within the object.</p>

    <p>This is a quick outline of the core concepts of Event-Driven Programming. This is in no way meant to be a full tutorial on Event-Driven Programming, it is meant to teach you just enough to use <em>Obj.JS</em>.</p>

    <h3>What's wrong with callbacks?</h3>
    <h6>Standard Callbacks Example</h6>
<pre info="JavaScript">
function MyProto(fooCallback, barCallback){
  this.foo = function(){
    console.log("Foo");
    if(fooCallback) fooCallback();
  };
  this.bar = function(){
    console.log("Bar");
    if(barCallback) barCallback();
  }
}

var myProtoInstance = new MyProto(function(){
  console.log("foo happened");
}, function(){
  console.log("bar happened");
});

myProtoInstance.foo();
myProtoInstance.bar();
</pre>
<pre info="Console">
Foo
foo happened
Bar
bar happened
</pre>

    <p>This above example works well because there are only 2 callback functions, but what if there were 10 or 20 or hundreds. This typical callback situation would not work well. And what if a prototype took 10 callbacks as parameters but you only wanted to specify callback 2 and 8.</p>
    <pre>var o = new FooBar(undefined, callback2, undefined, undefined, undefined, undefined, undefined, callback8)</pre>
    <p>This quickly becomes unmanageable.</p>

    <hr>
    <h3>Events</h3>
    <p>In Event-Driven programming, an "event" is a keyword that is listened for and triggered, to call callbacks rather than having to directly specify the callback. This can allow for hundreds of callbacks to be possible very easily. The only catch is that you must start listening for an event after the object has already been initialized.</p>

    <h5>How does it work?</h5>
    <p>EDP works by exposing 3 new methods on an object, one to start listening for an event, one to stop listening for an event, and one to indicate that the event has happened. There are two different common naming conventions for these methods on/off/trigger and subscribe(sub)/unsubscribe(unsub)/publish(pub). Obj.JS uses on/off/trigger so we will be using on/off/trigger from now on. Just remember if another site says "subscribe" that is our "on", "unsubscribe" is our "off", and "publish" is our "trigger".</p>

    <h5 id='on'><code>on(event, handler)</code></h5>
    <p>Event-Driven objects expose a public method called "on" (or "sub"). This allows other scripts to listen for events that happen to the object. This is typically called externally (outside the constructor) but can be used internally as-well.</p>
    <p>This method typically takes 2 arguments, the first is the name of the event that you are listening for, the second is the function that will be executed when the event occurs.</p>
    <p>The handler function should accept two arguments, the first is the name of the event that just occurred, and the second is some data about the event passed into the trigger/publish method.</p>

    <h5 id='off'><code>off([event [, handler]])</code></h5>
    <p>Event-Driven objects expose a public method called "off" (or "unsub"). This allows other scripts to stop listening for an event that happens to the object. This is typically called externally (outside the constructor) but can be used internally as-well.</p>
    <p>This method typically has two optional arguments, allowing it to be called in 4 different ways.</p>

    <h6><code>off()</code></h6>
    <p>Calling <code>off</code> with no arguments will remove all event handlers.</p>

    <h6><code>off(event)</code></h6>
    <p>Calling <code>off</code> with a single string as an argument will remove all event listeners for events that match the string.</p>

    <h6><code>off(event, handler)</code></h6>
    <p>Calling <code>off</code> with an string and a function as parameters will remove the event handler that matches the specified event and handler.</p>

    <h6><code>off(handler)</code></h6>
    <p>Calling <code>off</code> with a single function argument will remove this handler from all events it was listening for.</p>

    <h5 id='trigger'><code>trigger(event [, data])</code></h5>
    <p>Event-Driven objects expose a public method called "trigger" (or "pub"). This is used to tell the event system that an event just happened. This is typically called internally (from within the constructor) but can be used externally as-well.</p>
    <p>This method takes the name of the event as the first argument and optionally can take some data about the event as the second arguments.</p>

    <hr>
    <h3>Example</h3>
    <p>For this example lets assume we are extending an prototype called <code>EDP</code> and extending this prototype gives our prototype the methods discussed above.</p>
<pre info="JavaScript">
/* Define our prototype */
function FooBar(){
  EDP.apply(this); // Give our prototype EDP methods
  this.foo = function(){
    console.log("foo");
    this.trigger("foo", {
      fooData: "foo was a function that happened and this is it's data"
    });
  };
  this.bar = function(barArg1){
    console.log("bar ... " + barArg1);
    this.trigger("bar", barArg1);
  }
}
FooBar.prototype = Object.create(EDP.prototype);

/* Create an instance of our prototype */
var fb = new FooBar();

/* Listen for some events that happend within our instance */
fb.on("foo", function(event, data){
  console.log("foo happened: "+data.fooData);
});
fb.on("bar", function(event, data){
  console.log("bar happened");
});

/* Call some methods within our instance */
fb.foo();
fb.bar("This is an argument");
</pre>
<pre info="Console">
foo
foo happened: foo was a function that happened and this is it's data
bar ... This is an argument
bar happened
</pre>

    <p><br><br><br></p>
  </kempo-wrapper>
</body>
</html>
